#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import copy

import cv2
import numpy as np
import os
import sys
import yaml
from argparse import ArgumentParser
from glob import glob
from shutil import copyfile

try:
    from StringIO import StringIO
except ImportError:
    from io import BytesIO as StringIO

import rosbag
import rospy
import rospy.names
from cras_bag_tools import TopicSet, TqdmBag
from cras.image_encodings import isColor, isMono, isBayer, isDepth, bitDepth, numChannels, YUV422
from cv_bridge import CvBridge, CvBridgeError
from image_transport_codecs import decode, encode
from image_transport_codecs.compressed_depth_codec import has_rvl
from image_transport_codecs.parse_compressed_format import guess_any_compressed_image_transport_format
from sensor_msgs.msg import CompressedImage, Image


def is_sequence(o):
    return isinstance(o, (list, tuple))


def dict_as_kwargs(d):
    return ', '.join('%s=%s' % (k, v) for k, v in d.items())


def out_path(path, fmt):
    dirname, basename = os.path.split(path)
    name, ext = os.path.splitext(basename)
    out = fmt.format(dirname=dirname, name=name, ext=ext)
    try:
        os.makedirs(os.path.dirname(out))
    except OSError:
        pass
    return out


msg_to_raw_buffer = StringIO()


def msg_to_raw(msg):
    datatype = msg.__class__._type
    md5sum = msg.__class__._md5sum
    pytype = msg.__class__
    msg_to_raw_buffer.seek(0)
    msg_to_raw_buffer.truncate(0)
    msg.serialize(msg_to_raw_buffer)
    data = msg_to_raw_buffer.getvalue()
    return datatype, data, md5sum, pytype


def raw_to_msg(datatype, data, md5sum, pytype):
    msg = pytype()
    msg.deserialize(data)
    return msg


class MessageFilter(object):

    def __init__(self, is_raw):
        self.is_raw = is_raw
        self._include_topics = TopicSet()
        self._exclude_topics = TopicSet()
        self._include_types = TopicSet()
        self._exclude_types = TopicSet()
        self._min_stamp = None
        self._max_stamp = None

    def __call__(self, *args, **kwargs):
        return self.filter(*args, **kwargs)

    def consider_message(self, topic, datatype, stamp, header):
        """This function should be called before calling filter(). If it returns False, filter() should not be called
        and the original message should be used instead.

        :param str topic:
        :param str datatype:
        :param Time stamp:
        :param dict header:
        :return: Whether filter() should be called.
        :rtype: bool
        """
        if self._min_stamp is not None and stamp < self._min_stamp:
            return False
        if self._max_stamp is not None and stamp > self._max_stamp:
            return False
        if self._include_topics and topic not in self._include_topics:
            return False
        if self._exclude_topics and topic in self._exclude_topics:
            return False
        if self._include_types and datatype not in self._include_types:
            return False
        if self._exclude_types and datatype in self._exclude_types:
            return False
        return True

    def connection_filter(self, topic, datatype, md5sum, msg_def, header):
        """Connection filter passed to Bag.read_messages().

        :param topic:
        :param datatype:
        :param md5sum:
        :param msg_def:
        :param header:
        :return: If False, the topic will not be read from the input bag.
        :rtype: bool
        """
        return True

    def topic_filter(self, topic):
        """Filter of topics to be read from the bag file.

        :param topic:
        :return: If False, the topic will not be read from the input bag.
        :rtype: bool
        """
        return True

    @staticmethod
    def from_config(cfg):
        if cfg is None:
            return None
        # Assume cfg is either a filter config or a sequence of such configs.
        # If it is a sequence, construct filter chain.
        if is_sequence(cfg):
            return FilterChain([MessageFilter.from_config(d) for d in cfg])
        # Assume one of the following filter config structures:
        # {class: [args, kwargs]}.
        # {class: kwargs}.
        assert len(cfg) == 1
        k, v = list(cfg.items())[0]
        if is_sequence(v):
            args = v[0] if len(v) >= 1 else ()
            kwargs = v[1] if len(v) >= 2 else {}
        else:
            args = ()
            kwargs = v
        # Eval in the current environment.
        f = eval(k)(*args, **kwargs)
        return f

    def __str__(self):
        return self.__class__.__name__


class RawMessageFilter(MessageFilter):
    def __init__(self):
        super(RawMessageFilter, self).__init__(True)

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        raise NotImplementedError


class DeserializedMessageFilter(MessageFilter):
    def __init__(self):
        super(DeserializedMessageFilter, self).__init__(False)

    def filter(self, topic, msg, stamp, header):
        raise NotImplementedError


class Passthrough(RawMessageFilter):
    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        return topic, datatype, data, md5sum, pytype, stamp, header


class FilterChain(RawMessageFilter):
    def __init__(self, filters):
        super(FilterChain, self).__init__()
        self.filters = filters

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        # print(topic)
        msg = None
        last_was_raw = True
        for f in self.filters:
            # print(f)
            if not f.consider_message(topic, datatype, stamp, header):
                continue
            if f.is_raw:
                if not last_was_raw:
                    datatype, data, md5sum, pytype = msg_to_raw(msg)
                ret = f(topic, datatype, data, md5sum, pytype, stamp, header)
                if ret is None:
                    return None
                topic, datatype, data, md5sum, pytype, stamp, header = ret
                last_was_raw = True
            else:
                if last_was_raw:
                    msg = raw_to_msg(datatype, data, md5sum, pytype)
                ret = f(topic, msg, stamp, header)
                if ret is None:
                    return None
                topic, msg, stamp, header = ret
                datatype = msg.__class__._type  # needed in consider_message() above
                last_was_raw = False
        if not last_was_raw:
            datatype, data, md5sum, pytype = msg_to_raw(msg)
        return topic, datatype, data, md5sum, pytype, stamp, header

    def connection_filter(self, topic, datatype, md5sum, msg_def, header):
        for f in self.filters:
            if not f.connection_filter(topic, datatype, md5sum, msg_def, header):
                return False
        return True

    def topic_filter(self, topic):
        for f in self.filters:
            if not f.topic_filter(topic):
                return False
        return True

    def __str__(self):
        return '%s(%s)' % (self.__class__.__name__, ', '.join(str(f) for f in self.filters))

    def __iadd__(self, other):
        if other is None:
            return self
        assert isinstance(other, MessageFilter)
        if isinstance(other, FilterChain):
            self.filters += other.filters
            return self

        self.filters.append(other)
        return self

    def __add__(self, other):
        if other is None:
            return self
        assert isinstance(other, MessageFilter)
        if isinstance(other, FilterChain):
            return FilterChain(self.filters + other.filters)
        return FilterChain(self.filters + [other.filters])


class SetFields(DeserializedMessageFilter):
    def __init__(self, include_types, **kwargs):
        super(SetFields, self).__init__()
        self._include_types = TopicSet(include_types)
        self.field_values = kwargs

    def filter(self, topic, msg, stamp, header):
        for k, v in self.field_values.items():
            if k not in msg.__slots__:
                continue
            setattr(msg, k, v)
        return topic, msg, stamp, header

    def __str__(self):
        return '%s(%s, %s)' % (self.__class__.__name__, self._include_types, dict_as_kwargs(self.field_values))


class FixHeader(DeserializedMessageFilter):
    def __init__(self, include_topics=(), frame_id="", frame_id_prefix="", frame_id_suffix="",
                 stamp_from_receive_time=False, stamp_offset=0.0):
        super(FixHeader, self).__init__()
        self._include_topics = TopicSet(include_topics)
        self.frame_id = frame_id
        self.frame_id_prefix = frame_id_prefix
        self.frame_id_suffix = frame_id_suffix
        self.stamp_from_receive_time = stamp_from_receive_time
        self.stamp_offset = rospy.Duration(stamp_offset)

    def filter(self, topic, msg, stamp, header):
        if len(msg.__slots__) == 0 or msg.__slots__[0] != 'header':
            return topic, msg, stamp, header

        if len(self.frame_id) > 0:
            msg.header.frame_id = self.frame_id
        else:
            if len(self.frame_id_prefix) > 0:
                msg.header.frame_id = self.frame_id_prefix + msg.header.frame_id
            if len(self.frame_id_suffix) > 0:
                msg.header.frame_id += self.frame_id_suffix

        if self.stamp_from_receive_time:
            msg.header.stamp = stamp
        msg.header.stamp += self.stamp_offset

        return topic, msg, stamp, header

    def __str__(self):
        return '%s(%s, %s, %s, %s, %s, %i.%09u)' % (
            self.__class__.__name__, self._include_topics, self.frame_id, self.frame_id_prefix, self.frame_id_suffix,
            "True" if self.stamp_from_receive_time else "False", self.stamp_offset.secs, self.stamp_offset.nsecs)


class Remap(RawMessageFilter):
    def __init__(self, remap):
        super(Remap, self).__init__()
        self.remap = remap

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        return self.remap.get(topic, topic), datatype, data, md5sum, pytype, stamp, header

    def __str__(self):
        return '%s(%s)' % (self.__class__.__name__, self.remap)


class Throttle(RawMessageFilter):
    def __init__(self, **kwargs):
        super(Throttle, self).__init__()
        self.hz = kwargs
        self._include_topics = TopicSet(self.hz.keys())
        self.prev_t = {}

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        t = stamp.to_sec()
        if topic in self.prev_t:
            period = t - self.prev_t[topic]
            if period <= 0.:
                return None
            hz = 1. / period
            if hz > self.hz[topic]:
                return None
        self.prev_t[topic] = t
        return topic, datatype, data, md5sum, pytype, stamp, header

    def __str__(self):
        return '%s(%s)' % (self.__class__.__name__, self.hz)


class Topics(RawMessageFilter):
    def __init__(self, include=(), exclude=()):
        super(Topics, self).__init__()
        # do not use _include_topics and _exclude_topics here as they would not allow the filter to reject the messages
        self.include = TopicSet(include)
        self.exclude = TopicSet(exclude)

    def topic_filter(self, topic):
        if self.include and topic not in self.include:
            return False
        if self.exclude and topic in self.exclude:
            return False
        return True

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        # The filtering is done in topic_filter()
        return topic, datatype, data, md5sum, pytype, stamp, header

    def __str__(self):
        return ('%s(include=%s, exclude=%s)'
                % (self.__class__.__name__, self.include, self.exclude))


class TopicTypes(RawMessageFilter):
    def __init__(self, include=(), exclude=()):
        super(TopicTypes, self).__init__()
        # do not use _include_topics and _exclude_topics here as they would not allow the filter to reject the messages
        self.include = TopicSet(include)
        self.exclude = TopicSet(exclude)

    def connection_filter(self, topic, datatype, md5sum, msg_def, header):
        if self.include and datatype not in self.include:
            return False
        if self.exclude and datatype in self.exclude:
            return False
        return True

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        # The filtering is done in connection_filter()
        return topic, datatype, data, md5sum, pytype, stamp, header

    def __str__(self):
        return ('%s(include=%s, exclude=%s)'
                % (self.__class__.__name__, self.include, self.exclude))


class Transforms(DeserializedMessageFilter):
    def __init__(self, include_parents=(), exclude_parents=(), include_children=(), exclude_children=()):
        super(Transforms, self).__init__()
        self._include_types = TopicSet(['tf2_msgs/TFMessage'])
        self.include_parents = TopicSet(include_parents)
        self.exclude_parents = TopicSet(exclude_parents)
        self.include_children = TopicSet(include_children)
        self.exclude_children = TopicSet(exclude_children)

    def filter(self, topic, msg, stamp, header):
        if self.include_parents:
            msg.transforms = [tf for tf in msg.transforms if tf.header.frame_id in self.include_parents]
        if self.exclude_parents:
            msg.transforms = [tf for tf in msg.transforms if tf.header.frame_id not in self.exclude_parents]
        if self.include_children:
            msg.transforms = [tf for tf in msg.transforms if tf.child_frame_id in self.include_children]
        if self.exclude_children:
            msg.transforms = [tf for tf in msg.transforms if tf.child_frame_id not in self.exclude_children]
        if not msg.transforms:
            return None
        return topic, msg, stamp, header

    def __str__(self):
        return ('%s(include_parents=%s, exclude_parents=%s, '
                'include_children=%s, exclude_children=%s)'
                % (self.__class__.__name__, self.include_parents, self.exclude_parents,
                   self.include_children, self.exclude_children))


class FixSpotCams(RawMessageFilter):
    def __init__(self, include=()):
        super(FixSpotCams, self).__init__()
        self._include_topics = TopicSet(include)

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        header["message_definition"] = CompressedImage._full_text
        header["md5sum"] = md5sum = CompressedImage._md5sum
        header["type"] = datatype = CompressedImage._type
        pytype = CompressedImage

        return topic, datatype, data, md5sum, pytype, stamp, header


class MakeLatched(RawMessageFilter):
    def __init__(self, include=()):
        super(MakeLatched, self).__init__()
        self._include_topics = TopicSet(include)

    def filter(self, topic, datatype, data, md5sum, pytype, stamp, header):
        header["latching"] = "1"
        return topic, datatype, data, md5sum, pytype, stamp, header


class CompressImages(DeserializedMessageFilter):
    def __init__(self, include=(), exclude=(), only_color=False, only_depth=False, transport=None,
                 transport_params=None, transport_mapping=None, format_mapping=None):
        super(CompressImages, self).__init__()
        self._cv = CvBridge()

        self._include_types = TopicSet(['sensor_msgs/Image'])
        self._include_topics = TopicSet(include)
        self._exclude_topics = TopicSet(exclude)

        self.only_color = only_color
        self.only_depth = only_depth

        self.transport = transport
        self.transport_mapping = transport_mapping if transport_mapping is not None else {}
        self.transport_params = transport_params if transport_params is not None else {}
        # map of the raw images' encoding parameter to output image format
        self.format_mapping = format_mapping if format_mapping is not None else {}

    def filter(self, topic, msg, stamp, header):
        enc = msg.encoding
        is_color = isColor(enc) or isMono(enc) or isBayer(enc) or enc == YUV422
        is_depth = isDepth(enc)

        if (self.only_color and not is_color) or (self.only_depth and not is_depth):
            return topic, msg, stamp, header

        transport = ("compressedDepth" if is_depth else "compressed") if self.transport is None else self.transport
        transport = self.transport_mapping.get(enc, transport)

        compressed_msg, compressed_topic, err = self.get_image_for_transport(msg, topic, transport)
        # If encoding using compressedDepth fails, try with compressed
        if compressed_msg is None and transport == "compressedDepth":
            transport = "compressed"
            compressed_msg, compressed_topic, err = self.get_image_for_transport(msg, topic, transport)

        if compressed_msg is None:
            print('Error converting image: ' + str(err), file=sys.stderr)
            return topic, msg, stamp, header

        return compressed_topic, compressed_msg, stamp, header

    def get_image_for_transport(self, msg, topic, transport):
        compressed_topic = rospy.names.ns_join(topic, transport)

        config = self.transport_params.get(transport, {})
        if msg.encoding in self.format_mapping:
            config = copy.deepcopy(config)
            config["format"] = self.format_mapping[msg.encoding]
        # 16-bit images cannot be compressed to JPEG
        if transport == "compressed" and bitDepth(msg.encoding) > 8:
            config["format"] = "png"
        # Melodic doesn't have RVL
        if transport == "compressedDepth" and not has_rvl():
            config["format"] = "png"

        compressed_msg, err = encode(msg, compressed_topic, config)

        return compressed_msg, compressed_topic, err

    def __str__(self):
        return ('%s(include=%s, exclude=%s, only_color=%r, only_depth=%r, '
                'transport=%r, transport_params=%r, transport_mapping=%r format_mapping=%r)') % \
               (self.__class__.__name__, self._include_topics, self._exclude_topics,
                self.only_color, self.only_depth, self.transport, self.transport_params,
                self.transport_mapping, self.format_mapping)


class DecompressImages(DeserializedMessageFilter):
    def __init__(self, include=(), exclude=(), desired_encodings=None, transport=None, transport_config=None):
        super(DecompressImages, self).__init__()

        self._cv = CvBridge()

        self._include_types = TopicSet(['sensor_msgs/CompressedImage'])
        self._include_topics = TopicSet(include)
        self._exclude_topics = TopicSet(exclude)
        # map from topic to desired encoding of the raw images (one of the strings in sensor_msgs/image_encodings.h)
        self.desired_encodings = desired_encodings if desired_encodings is not None else {}
        self.transport = transport
        self.transport_config = transport_config if transport_config is not None else {}

    def filter(self, topic, msg, stamp, header):
        transport = self.transport
        raw_topic = topic
        if transport is None and "/" in topic:
            raw_topic, transport = topic.rsplit("/", 1)

        config = self.transport_config.get(transport, {}) if transport is not None else {}
        raw_img, err = decode(msg, topic, config)
        if raw_img is None:
            print('Error converting image: ' + str(err), file=sys.stderr)
            return topic, msg, stamp, header

        desired_encoding = self.desired_encodings.get(topic, 'passthrough')
        if desired_encoding == 'passthrough':
            return raw_topic, raw_img, stamp, header

        compressed_fmt, compressed_depth_fmt, err = guess_any_compressed_image_transport_format(msg)
        if compressed_fmt is None and compressed_depth_fmt is None:
            print('Error converting image to desired encoding: ' + str(err), file=sys.stderr)
            return raw_topic, raw_img, stamp, header

        raw_encoding = compressed_fmt.rawEncoding if compressed_fmt is not None else compressed_depth_fmt.rawEncoding
        if desired_encoding == raw_encoding:
            return raw_topic, raw_img, stamp, header

        try:
            cv_img = self._cv.imgmsg_to_cv2(raw_img, desired_encoding)
            return raw_topic, self._cv.cv2_to_imgmsg(cv_img, desired_encoding, raw_img.header), stamp, header
        except CvBridgeError as e:
            print('Error converting image to desired encoding: ' + str(e), file=sys.stderr)
            return raw_topic, raw_img, stamp, header

    def __str__(self):
        return ('%s(include=%s, exclude=%s, desired_encodings=%r, transport=%r, transport_config=%r)'
                % (self.__class__.__name__, self._include_topics, self._exclude_topics, self.desired_encodings,
                   self.transport, self.transport_config))


def fix_connection_header(header, raw_msg):
    datatype, _, md5sum, pytype = raw_msg
    header["message_definition"] = pytype._full_text
    header["md5sum"] = md5sum
    header["type"] = datatype
    return header


def filter_bag(bag, out, filter=Passthrough()):
    topics = [c.topic for c in bag._get_connections()]  # get all topics
    topics = [t for t in topics if filter.topic_filter(t)]  # apply topic filters
    topics = [c.topic for c in bag._get_connections(topics, filter.connection_filter)]  # apply connection filters

    connection_filter = filter.connection_filter
    for topic, msg, stamp, header in bag.read_messages(
            topics=topics, return_connection_header=True, raw=filter.is_raw, connection_filter=connection_filter):
        # Apply filter chain, discard message if None is returned.
        if filter.is_raw:
            datatype, data, md5sum, _, pytype = msg
            if filter.consider_message(topic, datatype, stamp, header):
                ret = filter(topic, datatype, data, md5sum, pytype, stamp, header)
                if ret is None:
                    continue
                topic, datatype, data, md5sum, pytype, stamp, header = ret
        else:
            if filter.consider_message(topic, msg.__class__._type, stamp, header):
                ret = filter(topic, msg, stamp, header)
                if ret is None:
                    continue
                topic, msg, stamp, header = ret
            datatype, data, md5sum, pytype = msg_to_raw(msg)
        raw_msg = (datatype, data, md5sum, pytype)
        # make sure connection header corresponds to the actual data type of the message
        # (if some filter forgot to update it)
        header = fix_connection_header(header, raw_msg)
        out.write(topic, raw_msg, stamp, connection_header=header, raw=True)


def copy_params_if_any(bag_path, out_bag_path):
    try:
        copyfile(bag_path + '.params', out_bag_path + '.params')
    except (OSError, IOError) as ex:
        print('Params (%s) not found.' % (bag_path + '.params'))


def filter_bags(bags, out_format, compression, filter):
    for bag_path in bags:
        out_bag_path = out_path(bag_path, out_format)
        copy_params_if_any(bag_path, out_bag_path)
        print()
        print('Source:      %s' % bag_path)
        print('Destination: %s' % out_bag_path)
        with TqdmBag(bag_path, skip_index=True) as bag, rosbag.Bag(out_bag_path, 'w', compression=compression) as out:
            bag.read_index()
            filter_bag(bag, out, filter)


def main():
    parser = ArgumentParser()
    parser.add_argument('bags', nargs='+')
    parser.add_argument('-i', '--incl-topics', nargs='+')
    parser.add_argument('-e', '--excl-topics', nargs='+')
    parser.add_argument('--throttle', '--hz', nargs='+')
    parser.add_argument('--incl-tf-parents', nargs='+')
    parser.add_argument('--excl-tf-parents', nargs='+')
    parser.add_argument('--incl-tf-children', nargs='+')
    parser.add_argument('--excl-tf-children', nargs='+')
    parser.add_argument('-c', '--config', nargs='+')
    parser.add_argument('-o', '--out-format')
    parser.add_argument('--lz4', dest='compression', action='store_const', const=rosbag.Compression.LZ4)
    parser.add_argument('--bz2', dest='compression', action='store_const', const=rosbag.Compression.BZ2)
    parser.add_argument('-f', '--filters', nargs='+')
    args = parser.parse_args()
    print()
    print('Command-line arguments:')
    for k, v in sorted(vars(args).items(), key=lambda kv: kv[0]):
        if v is not None:
            print('%s: %s' % (k, v))
    if args.throttle:
        topics = args.throttle[0:]
        hz = [float(hz) for hz in args.throttle[1:]]
        args.throttle = dict(zip(topics, hz))
    else:
        args.throttle = {}
    if args.config is None:
        args.config = []
    args.config = [list(glob(config)) for config in args.config]
    args.config = sum(args.config, [])
    for config in args.config:
        with open(config, 'r') as f:
            cfg = yaml.safe_load(f)
            for key in ['bags', 'out_format', 'compression',
                        'incl_topics', 'excl_topics', 'throttle',
                        'incl_tf_parents', 'excl_tf_parents',
                        'incl_tf_children', 'excl_tf_children',
                        'filters']:
                if args.__getattribute__(key) is None and key in cfg:
                    args.__setattr__(key, cfg[key])
    # Parse command-line args, also for backward compatibility.
    filters = []
    if args.incl_topics or args.excl_topics:
        filters.append(Topics(include=args.incl_topics,
                              exclude=args.excl_topics))
    if args.throttle:
        filters.append(Throttle(args.throttle))
    if args.incl_tf_parents or args.excl_tf_parents or args.incl_tf_children or args.excl_tf_children:
        filters.append(Transforms(include_parents=args.incl_tf_parents,
                                  exclude_parents=args.excl_tf_parents,
                                  include_children=args.incl_tf_children,
                                  exclude_children=args.excl_tf_children))
    filter = FilterChain(filters) + MessageFilter.from_config(args.filters)
    print()
    print('Filters:')
    print('\n'.join(str(f) for f in filter.filters))
    if args.compression is None:
        args.compression = rosbag.Compression.NONE

    filter_bags(args.bags, args.out_format, args.compression, filter)


if __name__ == '__main__':
    main()
